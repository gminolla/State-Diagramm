/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef STATE_DIAGRAMM_H_
#define STATE_DIAGRAMM_H_


#include <deque>
#include "..\src\sc_types.h"
#include "..\src\StatemachineInterface.h"

/*! \file Header of the state machine 'State_Diagramm'.
*/


#ifndef SCT_EVENTS_STATE_DIAGRAMM_H
#define SCT_EVENTS_STATE_DIAGRAMM_H
#ifndef SC_INVALID_EVENT_VALUE
#define SC_INVALID_EVENT_VALUE 0
#endif

namespace state_diagramm_events
{
typedef enum  {
	state_diagramm_invalid_event = SC_INVALID_EVENT_VALUE,
	InternalSCI_S,
	InternalSCI_k,
	InternalSCI_Extrd,
	InternalSCI_Retr,
	InternalSCI_Top,
	InternalSCI_Bottom,
	InternalSCI_SZ
} State_DiagrammEventName;

class SctEvent
{
	public:
		SctEvent(State_DiagrammEventName name) : name(name){}
		virtual ~SctEvent(){}
		const State_DiagrammEventName name;
		
};
		
template <typename T>
class TypedSctEvent : public SctEvent
{
	public:
		TypedSctEvent(State_DiagrammEventName name, T value) :
			SctEvent(name),
			value(value)
			{}
		virtual ~TypedSctEvent(){}
		const T value;
};

class SctEvent_InternalSCI_S : public TypedSctEvent<sc_boolean>
{
	public:
		SctEvent_InternalSCI_S(State_DiagrammEventName name, sc_boolean value) :
			TypedSctEvent(name, value) {};
};
class SctEvent_InternalSCI_k : public TypedSctEvent<sc_boolean>
{
	public:
		SctEvent_InternalSCI_k(State_DiagrammEventName name, sc_boolean value) :
			TypedSctEvent(name, value) {};
};
class SctEvent_InternalSCI_Extrd : public TypedSctEvent<sc_boolean>
{
	public:
		SctEvent_InternalSCI_Extrd(State_DiagrammEventName name, sc_boolean value) :
			TypedSctEvent(name, value) {};
};
class SctEvent_InternalSCI_Retr : public TypedSctEvent<sc_boolean>
{
	public:
		SctEvent_InternalSCI_Retr(State_DiagrammEventName name, sc_boolean value) :
			TypedSctEvent(name, value) {};
};
class SctEvent_InternalSCI_Top : public SctEvent
{
	public:
		SctEvent_InternalSCI_Top(State_DiagrammEventName name) : SctEvent(name){};
};
class SctEvent_InternalSCI_Bottom : public SctEvent
{
	public:
		SctEvent_InternalSCI_Bottom(State_DiagrammEventName name) : SctEvent(name){};
};
class SctEvent_InternalSCI_SZ : public SctEvent
{
	public:
		SctEvent_InternalSCI_SZ(State_DiagrammEventName name) : SctEvent(name){};
};

}
#endif /* SCT_EVENTS_STATE_DIAGRAMM_H */


/*! Define indices of states in the StateConfVector */
#define SCVI_MAIN_REGION_WAIT 0
#define SCVI_MAIN_REGION_INIT 0
#define SCVI_MAIN_REGION_READY 0
#define SCVI_MAIN_REGION_RETRACT 0
#define SCVI_MAIN_REGION_END 0
#define SCVI_MAIN_REGION_EXTRUDE 0
#define SCVI_MAIN_REGION_MEASUREMENT 0


class State_Diagramm : public StatemachineInterface
{
	public:
		State_Diagramm();
		
		virtual ~State_Diagramm();
		
		/*! Enumeration of all states */ 
		typedef enum
		{
			State_Diagramm_last_state,
			main_region_Wait,
			main_region_Init,
			main_region_Ready,
			main_region_Retract,
			main_region_End,
			main_region_Extrude,
			main_region_Measurement
		} State_DiagrammStates;
					
		static const sc_integer numStates = 7;
		
		//! Inner class for default interface scope.
		class DefaultSCI
		{
			public:
				DefaultSCI(State_Diagramm * parent):
					parent(parent)
				{}
				
				
			private:
				friend class State_Diagramm;
				State_Diagramm * parent;
				void dispatch_event(state_diagramm_events::SctEvent * event);
				
				
		};
		
		/*! Returns an instance of the interface class 'DefaultSCI'. */
		DefaultSCI* getDefaultSCI();
		
		
		/*
		 * Functions inherited from StatemachineInterface
		 */
		virtual void init();
		
		virtual void enter();
		
		virtual void exit();
		
		virtual void runCycle();
		
		/*!
		* Checks if the state machine is active (until 2.4.1 this method was used for states).
		* A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
		*/
		virtual sc_boolean isActive() const;
		
		
		/*!
		* Checks if all active states are final. 
		* If there are no active states then the state machine is considered being inactive. In this case this method returns false.
		*/
		virtual sc_boolean isFinal() const;
		
		
		/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
		sc_boolean isStateActive(State_DiagrammStates state) const;
		
		
		
	protected:
		
		
	private:
		
		//! Inner class for internal interface scope.
		class InternalSCI
		{
			public:
				InternalSCI(State_Diagramm * parent):
					S_raised(false),
					S_value(),
					k_raised(false),
					k_value(),
					Extrd_raised(false),
					Extrd_value(),
					Retr_raised(false),
					Retr_value(),
					Top_raised(false),
					Bottom_raised(false),
					SZ_raised(false),
					parent(parent)
				{}
				
				/*! Raises the in event 'S' that is defined in the internal scope. */
				void raise_s(sc_boolean value);
				
				/*! Checks if the out event 'S' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_s() const;
				
				/*! Gets the value of the out event 'S' that is defined in the internal scope. */
				sc_boolean get_s_value() const;
				
				
				/*! Raises the in event 'k' that is defined in the internal scope. */
				void raise_k(sc_boolean value);
				
				/*! Checks if the out event 'k' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_k() const;
				
				/*! Gets the value of the out event 'k' that is defined in the internal scope. */
				sc_boolean get_k_value() const;
				
				
				/*! Raises the in event 'Extrd' that is defined in the internal scope. */
				void raise_extrd(sc_boolean value);
				
				/*! Checks if the out event 'Extrd' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_extrd() const;
				
				/*! Gets the value of the out event 'Extrd' that is defined in the internal scope. */
				sc_boolean get_extrd_value() const;
				
				
				/*! Raises the in event 'Retr' that is defined in the internal scope. */
				void raise_retr(sc_boolean value);
				
				/*! Checks if the out event 'Retr' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_retr() const;
				
				/*! Gets the value of the out event 'Retr' that is defined in the internal scope. */
				sc_boolean get_retr_value() const;
				
				
				/*! Raises the in event 'Top' that is defined in the internal scope. */
				void raise_top();
				
				/*! Checks if the out event 'Top' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_top() const;
				
				
				/*! Raises the in event 'Bottom' that is defined in the internal scope. */
				void raise_bottom();
				
				/*! Checks if the out event 'Bottom' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_bottom() const;
				
				
				/*! Raises the in event 'SZ' that is defined in the internal scope. */
				void raise_sZ();
				
				/*! Checks if the out event 'SZ' that is defined in the internal scope has been raised. */
				sc_boolean isRaised_sZ() const;
				
				
				
			private:
				friend class State_Diagramm;
				/*! Raises the in event 'S' that is defined in the internal scope. */
				void internal_raise_s(sc_boolean value);
				sc_boolean S_raised;
				sc_boolean S_value;
				/*! Raises the in event 'k' that is defined in the internal scope. */
				void internal_raise_k(sc_boolean value);
				sc_boolean k_raised;
				sc_boolean k_value;
				/*! Raises the in event 'Extrd' that is defined in the internal scope. */
				void internal_raise_extrd(sc_boolean value);
				sc_boolean Extrd_raised;
				sc_boolean Extrd_value;
				/*! Raises the in event 'Retr' that is defined in the internal scope. */
				void internal_raise_retr(sc_boolean value);
				sc_boolean Retr_raised;
				sc_boolean Retr_value;
				/*! Raises the in event 'Top' that is defined in the internal scope. */
				void internal_raise_top();
				sc_boolean Top_raised;
				/*! Raises the in event 'Bottom' that is defined in the internal scope. */
				void internal_raise_bottom();
				sc_boolean Bottom_raised;
				/*! Raises the in event 'SZ' that is defined in the internal scope. */
				void internal_raise_sZ();
				sc_boolean SZ_raised;
				State_Diagramm * parent;
				void dispatch_event(state_diagramm_events::SctEvent * event);
				
				
		};
		
		//! the maximum number of orthogonal states defines the dimension of the state configuration vector.
		static const sc_ushort maxOrthogonalStates = 1;
		
		
		
		State_DiagrammStates stateConfVector[maxOrthogonalStates];
		
		sc_ushort stateConfVectorPosition;
		
		
		DefaultSCI iface;
		InternalSCI ifaceInternalSCI;
		
		// prototypes of all internal functions
		
		sc_boolean check_main_region__choice_0_tr0_tr0();
		void effect_main_region__choice_0_tr0();
		void effect_main_region__choice_0_tr1();
		void enseq_main_region_Wait_default();
		void enseq_main_region_Init_default();
		void enseq_main_region_Ready_default();
		void enseq_main_region_Retract_default();
		void enseq_main_region_End_default();
		void enseq_main_region_Extrude_default();
		void enseq_main_region_Measurement_default();
		void enseq_main_region_default();
		void exseq_main_region_Wait();
		void exseq_main_region_Init();
		void exseq_main_region_Ready();
		void exseq_main_region_Retract();
		void exseq_main_region_End();
		void exseq_main_region_Extrude();
		void exseq_main_region_Measurement();
		void exseq_main_region();
		void react_main_region__choice_0();
		void react_main_region__entry_Default();
		sc_boolean react();
		sc_boolean main_region_Wait_react(const sc_boolean try_transition);
		sc_boolean main_region_Init_react(const sc_boolean try_transition);
		sc_boolean main_region_Ready_react(const sc_boolean try_transition);
		sc_boolean main_region_Retract_react(const sc_boolean try_transition);
		sc_boolean main_region_End_react(const sc_boolean try_transition);
		sc_boolean main_region_Extrude_react(const sc_boolean try_transition);
		sc_boolean main_region_Measurement_react(const sc_boolean try_transition);
		void clearInEvents();
		void clearOutEvents();
		
		
		std::deque<state_diagramm_events::SctEvent*> internalEventQueue;
		state_diagramm_events::SctEvent* getNextEvent();
		void dispatch_event(state_diagramm_events::SctEvent * event);
		
		
};




#endif /* STATE_DIAGRAMM_H_ */
